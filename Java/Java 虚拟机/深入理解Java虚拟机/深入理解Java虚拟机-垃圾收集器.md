##深入理解Java虚拟机——垃圾收集器
关于垃圾收集(Garbage Collection，GC)，需要关注的3件事情是：

* 哪些内存需要回收？
* 什么时候进行回收？
* 如何回收？

###需要分配与回收的内存
* Java 内存运行时区域的各个部分，其中程序计时器、虚拟机栈、本地方法3个区域的生命周期与拥有它们的线程一样；栈中的栈帧随着方法的进入和退出而执行出栈和入栈操作，每一个栈帧中分配的内存基本上时再类结构确定下来的时候就确定。因此这几个区域的内存分配与回收都具备确定性，在这几个区域中不需要过多地考虑回收的问题
* 而Java堆和方法区则不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，我们只有在程序处于运行期间时才能知道会创建哪些对象，这部分内存的分配与回收是动态的，垃圾收集器所主要关注的是这部分的内存

###确定对象是否需要回收
垃圾收集器在对堆进行回收之前，需要确定内存中哪些对象是“存活”，哪些是“死去”的

####判断算法
#####1、引用计数算法(Reference Counting)
######算法描述：
给对象添加一个引用计数器，每当有一个地方引用它时，计数器值就加 1，当引用失效时，计数器值就减 1；任何时刻计数器为 0 的对象就是不可能再被使用。

######算法存在的问题：
尽管，引用计数法的实现简单，判断效率也很高，在大部分情况下都是一个不错的算法。但是 Java 虚拟机并没有采用引用计算算法来管理内存，其中最主要的原因是：这种算法难以解决对象之间的相互循环引用的问题。
**相互循环引用**:例如，对象 objA 和 objB 都有字段 instance ，赋值令 objA.instance = onjB 及 objB.instance = objA,除此之外，这两个对象没有其他的引用，实际上这两个对象已经不可能再被访问，但因为它们互相引用对方，导致它们的引用计数器都不为 0 ，垃圾收集器无法回收它们

#####2、可达性分析算法(Reachability Analysis)
######算法描述：
这个算法是通过一系列称为“GC Roots”的对象作为起点，从这些起点开始向下搜索，搜索所走过的路径称为引用链(Reference Chain)，当一个对象到 GC Roots 没有任何引用链相连（用图论的话来说，就是从 GC Roots 到这个对象是不可达），则证明此对象是不可用的。

![](http://www.kuqin.com/upimg/allimg/110906/224Q63918-0.JPG)

######在 Java 中，作为 GC Roots 的对象包括下面：
* 虚拟机栈（栈帧中的本地变量表）中引用的对象
* 方法区中类静态属性引用的对象
* 方法区中常量引用的对象
* 本地方法栈中 JNI 引用的对象

####关于引用的问题
* 无论是引用计数算法，还是可达性分析算法，它们判断对象是否存活都与“引用”有关
* 在 JDK 1.2 之前，Java 中引用的定义很简单，只有被引用和没有被引用两种状态，如果 reference 类型的数据中存储的数值代表的是另一块内存中的起始地址，就称这块内存代表这一个引用
* 在 JDK 1.2 之后，Java 对引用的概念进行了扩充。将引用分为：强引用(Strong Reference)、软引用(Soft Reference)、弱引用(Weak Reference)、虚引用(Phantom Reference)4种，这4种引用强度依次逐渐减弱
  * 强引用(Strong Reference)：在程序代码种普遍存在的，类似于"Object obj = new Object()"这类的引用，只要强引用还存在，垃圾收集器永远不会回收被引用的对象
  * 软引用(Soft Reference)：用来描述一些还有用但并非必要的对象，对于软引用关联着的对象，在系统将要发生内存溢出之前，才对这些对象进行内存回收。如果在这次回收后还没有足够的内存，就会抛出内存溢出
  * 弱引用(Weak Reference)：同样也是用来描述非必须的对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象
  * 虚引用(Phantom Reference)：它是最弱的引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来去的一个对象的实例，为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集其回收之前收到一个系统通知

####对象是生存还是死亡
即使在可达性分析算法中的不可达对象，也并非马上被内存回收，至少经过两次标记过程。
* 在第一次标记中，将会对对象进行筛选，筛选条件是此对象是否有必要执行的 `finalize()` 方法，如果对象没有覆盖`finalize()` 方法，或者 `finalize()` 方法已经被虚拟机调用过，那么这个对象将被视为“没有必要执行”，否则这个对象将会被放置到 F-Queue 队列中，并执行`finalize()` 方法
* 第二次标记中，如果对象在`finalize()` 方法中重新与引用链上的任何一个对象建立关联，那么这个对象将被移出“即将回收”集合。否则此对象基本上会被进行回收

####对方法区的回收
Java 虚拟机贵方中不要求虚拟机在方法区实现垃圾回收，而且方法区中进行垃圾回收的效率比较低。方法区的回收并不是内存回收主要关注的地方
方法区中的垃圾回收主要回收以下两部分内容：
* 废弃常量。回收废弃常量与回收 Java 堆中的对象类似，只要没有其他地方引用这个常量，那么这个常量将会被回收
* 无用的类。判定一个类是否是“无用的类”的条件相对苛刻不少。类需要同时满足以下3个条件才能算是“无用的类”
  * 该类的所有实例已经被回收，也就是 Java 堆中不存在该类的任何实例
  * 加载该类的 ClassLoader 已经被回收
  * 该类对应的 `java.lang.Class` 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法

###垃圾收集算法
####1.标记-清除（Mark-Sweep）算法
######算法描述：
* 最基础的收集算法，后续的收集算法都是基于这种思路对其的不足进行改造而得到的
* 算法分为：标记、清除两个阶段，首先是标记出所有需要回收的对象（标记的过程使用前面提到的引用计数算法和可达性分析算法等算法判断对象存活），在标记完成后统一回收所有被标记的对象

######主要不足：
1. 效率问题，标记和清除的两个过程的效率都不高
2. 空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多会导致以后在程序运行过程中需要分配较大对象是，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作

######标记-清除（Mark-Sweep）算法示意图
![](http://static.oschina.net/uploads/space/2015/0725/162639_lRPR_1983603.png)

####2.复制(Cpoying)算法
######算法描述：
* 这中算法将可用内存按容量划分为大小相等的两块，没次只使用其中的一块。当这一块的内存用完了，就将还存在的对象复制到另一块内存上，然后再把已使用过的内存空间一次清除掉。这样使得每次都是对整个半区进行内存回收。

######主要优缺点
* 好处是内存分配不用考虑内存碎片的复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。
* 不足是这种算法的代价是将内存缩小为原来的一半，代价太高。

######复制(Cpoying)算法示意图
![](http://www.2cto.com/uploadfile/2013/0619/20130619113341423.jpg)

######应用
* 现在的商业虚拟机都采用这种收集算法来回收**新生代**
* HotSpot 中并没有按照 1 ：  1 比例来划分内存空间，而是将内存分为一块较大的 Eden 空间和两块较小的 Survivor 空间（HotSpot 虚拟机默认的 Eden 和 Survivor 的大小比例是 8 : 1），每次使用 Eden 空间和其中的一块 Survivor。当回收是，将 Eden 和 Survivor 中仍存活的对象一次性复制到另一块 Survivor 空间上，最后清除掉 Eden 和刚才使用过的 Survivor 空间。
* HotSpot 虚拟机默认的 Eden 和 Survivor 的大小比例是 8 : 1 的布局意义在于：新生代中的对象 98% 生命周期较短，可提高效率。但是由于没有办法保证每次回收都只有不多于 10% 的对象存活，所以当 Survivor 空间不够用是，需要进行分配担保(Handle Promotion)

####3.标记-整理(Mark - Compact)算法
######算法描述
* 标记-整理(Mark - Compact)算法，标记过程仍然与 “标记-清除” 算法一样，但后续步骤不是直接对可回收的对象进行清除，而是样所有存活的对象都向一端移动，然后直接清理掉边界以外的内存

######不足之处
* 复制成本较高

######标记-整理(Mark - Compact)算法示意图
![](http://www.2cto.com/uploadfile/Collfiles/20160502/20160502112303425.jpg)

####4.分代(Generation Collection)算法
* 当前商业虚拟机的垃圾收集器都采用“分代收集”算法，这种算法并没有什么新的思想，只是根据对象的存活周期将内存划分为几块。一般是把 Java 堆划分为**新生代**和**老年代**，这样就可以根据各个年代的特点采用最适当的算法
* 在新生代中，每次垃圾回收是都会发现有大批对象死去，只有少量存活，因而选用**复制算法**，只需要付出少量存活对象的复制成本就可以完成收集
* 在老年代中，因为对象的存活率高、没有额外空间对它进行分配担保，就必须采用**标记-清除（Mark-Sweep）算法** 或 **标记-整理(Mark - Compact)算法** 进行回收

###HotSpot 的算法实现的一些概念
####枚举根节点(root enumeration)
主流的虚拟机实现对对象的判定都采用可达性分析算法。由于可达性分析是从 GC Roots 节点来找引用链的，可作为 GC Roots 节点主要在全局性的引用（例如常量或静态属性）与执行上下文（例如栈帧中的本地变量表）中。因而 GC 时就需要逐个检查里面的所有引用

######这种枚举根节点方式需要解决的问题是：
* 很多应用仅仅方法区就很大，如果要逐个检查里面的引用类型，必然需要消耗大量的时间
* GC 停顿问题，由于 GC 的这项分析工作必须在在一个能确保一致性的快照中进行，意思是在整个分析期间整个执行系统不能出现对象引用关系变化的情况，否则分析结果的准确性无法得到保证。而在此 GC 进行期间，将停顿所有 Java 执行线程。

######解决办法
* 由于目前主流的 Java 虚拟机使用的都是准确式 GC ，当执行系统停顿下来的时候，并不需要检查完所有的执行上下文和全局的引用位置
* 在 HotSpot 虚拟机的实现中，使用了一组称为 OopMap 的数据结构来达到这个目的。
* OopMap 保存有引用类型的映射位置。意思是 HotSpot 会在类加载完成时，将对象中什么偏移量上时什么类型的数据计算出来并保存到 OopMap 中，也会在 JIT 编译过程中记录下栈和寄存器中哪些位置是引用
* GC 在扫描时，根据 OopMap 就可以直接知道什么地方是什么类型，什么地方是一个引用

####安全点(Safepoint)
前面提到，每一个被 JIT 编译的过的方法都会在特定的地方记录下 OopMap，记录了执行到这个方法的某条指令是，栈和寄存器上哪些位置是引用，这样 GC 在扫描的时候就会查询 OopMap 就知道哪些是引用了。

######什么是安全点
上述 OopMap 问题是：方法中包含的指令非常多，而 OopMap 内容变化（引用关系变化）的指令也非常多，如果每一条指令都生成对应的 OopMap ，GC 的空间成本将会变得很高，因而只能在特定的位置记录下 OopMap，这些位置称为**安全点（Safepoint）**，即程序并非在所有地方都能停下来开始 GC ，只有到达安全点才能暂停。
######安全点的选取
* 安全点的选定太少会导致 GC 的等待时间太长，而安全点选取太多会导致多分增大运行时的符合
* 安全点的选取基本上是以程序”是否具有让程序长时间执行的特征“为标准进行选定，这些特定的位置主要是：循环的末尾、方法临返回前 / 调用方法的call指令后、可能抛异常的位置等

######GC 执行时线程的中断方式
如何在 GC 发生时让所有的线程（不包括执行 JNI 调用的线程）执行到最近的安全点再听停顿下来，有两种方案：

1. **抢先式中断(Preemptive Suspension)**：抢先式中断不需要线程的执行代码主动去配合，在 GC 发生时，首先把所有的线程全部中断，如果发现有线程中断的地方不在安全点上，则恢复线程，直至执行到安全点。现在几乎没有虚拟机的实现采用抢先式中断来暂停线程从而响应 GC 事件
2. **主动式中断(Voluntary Suspension)**：主动式中断的思想是当 GC 需要中断线程的时候，不直接对线程操作，仅仅简单地设置一个标志，各个线程在执行时主动去轮询这个标志，发现中断标志为真时就自己中断挂起。轮询的地方和安全点是重合的，另外再加上创建对象需要分配内存的地方。

####安全区域(Safe Region)
######安全点存在的问题
安全点机制保证了程序在执行时，在不太长的时间内就会遇到可进入的 GC 的安全点。但是如果 GC 发生时，有的线程不能到达安全点（典型的例子是：线程处于 Sleep 状态或 Blocked 状态），这时候线程无法响应中断的请求执行到安全点再挂起。这时候 GC 需要等待该线程重新执行并在安全点挂起，此时其他的线程也需要一直在安全点挂起等待，显然是不现实的。

######什么是安全区域
为了解决上述的情况，可以通过指定**安全区域(Safe Region)**来解决，安全区域指的是的一段代码片段中，引用关系不会发生变化。在这个区域中的任何地方开始 GC 都是安全的。可以把 安全区域看作是扩展了的 安全点。

######安全区域的使用
在线程执行到 Safe Region 中的代码是，首先标识自己已经进入了 Safe Region ，那样，当在这段时间里 JVM 发起 GC 时，就不需要管将自己标识为 Safe Region 状态的线程。而在线程要离开 Safe Region 时，它需要检查系统是否已经完成了 GC，如果完成了，那么线程就继续执行，否则它必须等待直到收到可以安全离开 Safe Region 信号的时间为止



### 垃圾收集器

如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。Java虚拟机规范中对象垃圾收集器应该如何实现并没有任何规定，因此不同的厂商，不同版本的虚拟机所提供的收集器可能会有很的差别，并且一般会提供参数供用户根据自己的应用特点和要求组合出各个年代所使用的收集器。

######  Hotspot 虚拟机包含的收集器示意图：

![](https://raw.githubusercontent.com/KEN-LJQ/MarkdownPics/master/Resource/hotspot%20%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8.png)

###### 注意：

* 上图中如果两个收集器之间存在连线，就说明它们之间可以搭配使用。虚拟机所处的区域，则表示它是属于新生代收集器还是老年代收集器
* 没有最好的垃圾收集器，垃圾收集器的选择需要针对具体的应用



#### Serial 收集器

* Serial 收集器是最基本、发展历史最悠久的收集器，在 JDK 1.3.1 之前是虚拟机**新生代收集器**的唯一选择
* 这个收集器是一个单线程的收集器，它只会使用一个 CPU 或一条收集线程去完成垃圾收集工作，而且在垃圾收集时，必须暂停其他所有的工作线程，直到收集结束。这项工作实际上虚拟机在后台自动发起和自动完成的，在用户不可见的情况下把用户正常工作的线程全部停掉，称为**“Stop The World”**

###### Serial / Serial Old 收集器运行示意图：

![](https://raw.githubusercontent.com/KEN-LJQ/MarkdownPics/master/Resource/Serial%20Serial%20Old%20%E6%94%B6%E9%9B%86%E5%99%A8%E8%BF%90%E8%A1%8C%E7%A4%BA%E6%84%8F%E5%9B%BE.png)

###### 注意：

* Serial 收集器依然是虚拟机运行在 Client 模式下的默认新生代收集器。原因是：
  * 在线程或限定单个 CPU 的环境下，Serial 收集器相比与其他收集器来说简单高效，没有线程交互的开销，可以获得较高的单线程回收率。
  * 在 Client 模式下，分配给虚拟机的内存一般来说不会很大，因而垃圾收集带来的停顿时间可以控制到比较小可以接受的程度



#### ParNew 收集器

* ParNew 收集器也是**新生代收集器**，是 Serial 收集器的多线程版本，除了使用了多条线程进行垃圾收集之外，其与行为包括 Serial 收集器可用的所有控制参数、对象分配策略、回收策略都与 Serial 收集器一样

###### ParNew 收集器运行示意图：

![](https://raw.githubusercontent.com/KEN-LJQ/MarkdownPics/master/Resource/ParNew%E6%94%B6%E9%9B%86%E5%99%A8.png)

###### 注意：

* Parnew 收集器许多运行在 Server 模式下的虚拟机中首选的新生代收集器，其中一个重要的原因是：除了 Serial 收集器外，目前只有它能与 CMS 收集器配合工作
* 由于多线程交互的开销，ParNew 收集器在单 CPU 环境在不会有比 Serial 收集器更好的收集效果。但是随着使用的 CPU 数量的增加，ParNew 收集器能够提高 GC 时系统资源的有效利用



#### Parallel Scavenge 收集器

* Parallel Scavenger 收集器与 ParNew 收集器类似，是一个**新生代收集器**，垃圾收集采用复制算法，又是并行的多线程收集器
* Parallel Scavenge 收集器的关注点与其他的收集器不同，其他收集器的关注点是尽可能地缩短垃圾收集是用户线程的停顿时间，而 Parallel Scavenge 收集器的目标是达到一个控制的**吞吐量(Throughput)**
* **吞吐量**就是 CPU 用于运行用户代码的时间与 CPU 总消耗时间的比值，即吞吐量 = 运行用户代码时间 /(运行用户代码时间 + 垃圾收集时间)；停顿时间越短越适合需要与用户交互的程序，而高吞吐量可以高效率地利用 CPU 时间，尽快地完成程序的运算任务，主要适合后台运算而不需要太多交互的任务
* Parallel Scavenge 收集器提供了两个参数用于精确控制吞吐量：
  * `-XX:MaxGCPauseMilis`参数：控制最大垃圾收集停顿时间
  * `-XX:GCTimeRatio`参数：直接设置吞吐量大小
* Parallel Scavenge 收集器还提供了 GC 自适应的调节策略 (GC Ergonomics)的调节方式，这个参数是：`-XX:+UseAdaptiveSizePolicy`，这是一个开关参数，当这个开关打开后，虚拟机回根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量。这个是 Parallel Scavenge 收集器与 ParNew 收集器的一个重要区别



#### Serial Old 收集器

* Serial Old 收集器是 Serial 收集器的**老年代收集器**，是一个单线程收集器，使用**“标记-整理”**算法。
* 这个收集器主要是给 Client 模式下的虚拟机使用。在 Server 模式下主要用途是：在 JDK 1.5 以及之前版本中与 Parallel Scavenge 收集器搭配使用，另外是作为 CMS 收集器的后备预案

###### Serial Old 收集器的运行示意图：

![](https://raw.githubusercontent.com/KEN-LJQ/MarkdownPics/master/Resource/Serial%20Serial%20Old%20%E6%94%B6%E9%9B%86%E5%99%A8%E8%BF%90%E8%A1%8C%E7%A4%BA%E6%84%8F%E5%9B%BE.png)

#### Parallel Old 收集器

* Parallel Old 是 Parallel Scavenge 收集器的**老年代版本**，是一个多线程收集器，以及使用**“标记-整理”**算法进行垃圾收集
* 在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 搭配 Parallel Old 收集器，这个**吞吐量优先**组合

###### Parallel Old 收集器的运行示意图：

![](https://raw.githubusercontent.com/KEN-LJQ/MarkdownPics/master/Resource/Parallel%20Old%E6%94%B6%E9%9B%86%E5%99%A8.png)

#### CMS 收集器

* **CMS (Concurrent Mark Sweep) 收集器** 是一个以获取最短回收停顿时间为目标的收集器

* CMS 收集器是基于**“标记-清除”**算法实现的，它的运行过程更加复杂，整个过程分为 4 个步骤：

  * 初始标记(CMS initial mark)
  * 并发标记(CMS concurrent mark)
  * 重新标记(CMS remark)
  * 并发清除(CMS concurrent sweep)

  其中，初始标记、重新标记这两个步骤任然需要“Stop The World”。**初始标记**阶段仅仅只是标记以下 GC Roots 直接关联到的对象，速度很快，**并发标记**阶段就是进行 GC Roots Tracing 的过程，**重新标记**阶段是修正并发标记期间因用户程序继续运行而导致标志产生变动的一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记解阶段长一些，但比并发标记短

* 由于整个过程中耗时最长的**并发标记**和**并发清除**步骤，垃圾收集器线程可以与用户线程一起工作，因而 CMS 收集器的内存回收过程与用户线程是一起并发执行的

###### CMS 收集器运行示意图;

![](https://raw.githubusercontent.com/KEN-LJQ/MarkdownPics/master/Resource/CMS%E6%94%B6%E9%9B%86%E5%99%A8.png)

###### 注意：

CMS 的主要优点是：并发收集、低停顿，但是这款收集器有 3 个明显的缺点：

* CMS 收集器堆 对 CPU 资源非常敏感。并发阶段，它虽然不会导致用户进程停顿，但是会占用一部分线程或者是 CPU 资源而导致应用程序变慢，总吞吐量降低
* CMS 收集器无法处理浮动垃圾(Floating Garbage)，可能出现**“Concurrent Mode Failure”**失败而导致另一次 Full GC 的产生。浮动垃圾是在 CMS 并发清除阶段，用户线程运行产生的未标记的，CMS在当次收集中无法清除的这一部分垃圾
* CMS 收集器的基于**“标记-清除”**算法实现意味着垃圾收集结束时会有大量空间碎片产生。空间碎片过多将会给大对象的分配带来很大麻烦，往往会出现老年代还有很大的空间剩余，但是没有足够大的连续空间来分配当前对象而触发一次 Full GC。



### G1 收集器

* **G1(Garbage-First)** 收集器是当今收集器技术发展最前沿成果之一，它是一款面向服务端应用的垃圾收集器。Hotspot 团队希望这款收集器可以在未来替换 JDK 1.5 中发布的 CMS 收集器。G1 收集器具有以下特点：

  * 并行与并发：G1 能充分利用多 CPU 、多核环境下的硬件优势，使用多个 CPU 核心来缩短 Stop-The-World 停顿的时间
  * 分代收集：虽然仍然保留了分代收集的概念，但 G1 独立管理整个堆，但是能够采用不同的方式去处理新创建对象和已经存活了一段时间、熬过多次GC的旧对象，以获取更好的收集效果。
  * 空间整合：G1 从整体上来看是基于”标记-整理“算法实现的收集器，但是从局部(两个 Region 之间) 来看是基于”复制“算法实现的。意味着 G1 运行期间不会产生内存空间碎片，手机后能提供规整可用内存
  * 可预测的停顿：G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒

* G1 收集器使用 Region 划分内存空间以及有优先级地区域回收。G1 收集器的 Java 堆内存布局与其他收集器有很大差别，它将整个 Java 堆划分为多个大小相等的独立区域(**Region**)，虽然还保留了新生代和老年代的概念，但新生代和老年代不再是物理隔离，它们都是一部分 Region 的集合。G1 会跟踪各个 Region 的回收价值，建立一个优先列表，每次根据允许的回收时间优先回收价值最大的 Region，获取尽可能高的回收率。

* 在 G1 收集器垃圾收集过程中，为了避免 Region 之间的对象引用可能带来全堆扫描，G1 通过为每一个 Region 设立一个 **Remembered Set** 来解决。**Remembered Set** 会记录下本 Region 中对象对其他 Region 中对象的 Reference 引用信息，当进行内存会回收时，在 GC 根节点的枚举范围加入 Remember Set 即可保证不对全堆扫描也不会有遗漏

* G1 收集器的运作步骤：

  * 初始标记(Initial Marking)
  * 并发标记(Concurrent Marking)
  * 最终标记(Final Marking)
  * 筛选标记(Live Data Counting and Evacuation)

  **初始标记**阶段仅仅时标记以下 GC Root 能够直接关联的对象，并且修改 TAMS 的值，这一阶段需要停顿线程，但耗时很短；**并发标记**阶段是从 GC Root 开始对堆中的对象进行可达性分析，耗时较长，但可与用户程序并发执行；**最终标记**阶段是修正在并发标记期间因用户程序继续运行而导致标记发生变动的那一部分标记记录

###### G1 收集器运行示意图：

![](https://raw.githubusercontent.com/KEN-LJQ/MarkdownPics/master/Resource/G1%E6%94%B6%E9%9B%86%E5%99%A8.png)
##深入理解Java虚拟机——虚拟机字节码执行引擎

>执行引擎是 Java 虚拟机最核心的组成部分之一。“虚拟机”是一个相对于“物理机”的概念，这两种机器都有代码执行能力，其区别在于物理机的执行引擎是直接建立在处理器上、硬件、指令集和操作系统层面上的，而虚拟机的执行引擎则是由自己实现的。

>在 Java 虚拟机规范中制定了虚拟机字节码执行引擎的概念模型，这个概念模型成为各种虚拟机执行引擎的统一外观(Facade)——输入的是字节码文件，处理过程是字节码解析的等效过程，输出的执行结果



###运行时栈帧结构

* 栈帧(Stack Frame)是用于支持虚拟机进行方法调用的方法执行的数据结构，它是虚拟机运行时数据区中的虚拟机栈(Virtual Machine Stack)的栈元素。每个方法从调用开始到执行完成的过程，都对应着一个栈帧在虚拟机栈里面从入栈到出栈的过程

* 栈帧存储了方法的局部变量表、操作数栈、动态连接和方法返回地址等信息

* 在编译程序代码的时候，栈帧中需要多大的局部变量表，多深的操作数栈都是完全确定的，并且写入到方法表的 Code 属性中

* 一个线程中的方法调用链可能回很长，很多方法同时处于执行状态。但对于执行引擎来说，在活动线程中，只有位于栈顶的栈帧是有效的，称为当前栈帧(Currnt Stack Frame)，这个栈帧所关联的方法称为当前方法(Current Method)。执行引用所运行的所有字节码指令都只针对当前栈帧进行操作



######栈帧的概念结构如下



![](http://images.cnitblog.com/blog/491386/201307/16221832-d817a26b269f42c8a9b2d4cbf627b0cf.jpg)



###局部变量表

局部变量表是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量。在Java程序编译为Class文件时，就在方法表的Code属性的max_locals数据项中确定了该方法需要分配的最大局部变量表的容量。



####变量槽(Variable Slot,Slot)

* 局部变量表的容量是以变量槽为最小单位，虚拟机规范中并没有明确指出一个 Slot 应占用的内存空间大小

* 一个 Slot 可以存放一个32位以内的数据类型，Java 中占用32位以内的数据类型有：boolean、byte、char、short、float、reference 和 returnAddress 8种类型

* 对于64位的数据类型，虚拟机会以高位对齐的方式为其分配两个连续的 Slot 空间。Java 种明确规定的64位的数据类型只有 long 和 double 两种。另外由于局部变量表是线程私有的，所以无论读取两个连续的 Slot 是否为原子操作，都不会引起安全问题



####局部变量表的使用

* 虚拟机通过索引定位的方式使用局部变量表索引值的范围是从 0 开始至局部变量表最大的 Slot 数量。而且虚拟机不允许采用任何方式单独访问64位数据的两个 Slot 中的其中一个

* 在方法执行时，虚拟机是使用局部变量表完成参数变量列表的传递过程（方法传入参数）

* 局部变量表中第 0 位索引的 Slot 默认是用于传递一个方法所属对象实例的引用，在方法中可以通过 this 关键字来访问这个隐含参数，其余参数则按照参数列表的顺序来排列，占用从1开始的局部变量Slot，参数表分配完毕后，再根据方法体内部定义的变量顺序和作用域来分配其余的Slot。



####局部变量表的 Slot 重用

* 局部变量表中的Slot是可重用的，方法体中定义的变量，其作用域并不一定会覆盖整个方法，如果当前字节码PC计算器的值已经超出了某个变量的作用域，那么这个变量对应的Slot就可以交给其它变量使用。



######注意：

局部变量不像前面介绍的类变量那样存在“准备阶段”。类变量有两次赋初始值的过程，一次在准备阶段，赋予系统初始值；另外一次在初始化阶段，赋予程序员定义的值。因此即使在初始化阶段程序员没有为类变量赋值也没有关系，类变量仍然具有一个确定的初始值。但局部变量就不一样了，如果一个局部变量定义了但没有赋初始值是不能使用的。但是编译器在编译期间会检查到并提示，而且在字节码校验得时候也会被虚拟机发现而导致类加载失败


###操作数栈

* 操作数栈(Operand Stack) 也称为操作栈，它是一个后入先出(Last In First Out) 栈。同局部变量表一样，操作数栈的最大深度在编译的时候写入到 Code 属性的 `max_stack` 数据项中
* 操作数栈的每一个元素可以是任意的Java类型，包括long和double类型。32位的数据类型所占的栈容量为1，64位数据类型所占的栈容量为2.在方法执行的任何时候，操作数栈的升读都不会超过max_stack数据项中设定的最大值
* 当一个方法在开始执行的时候，这个方法的操作数栈是空的，在方法执行过程中会有各种字节码指令往操作数栈中写入和提取内容。例如，在做算术运算的时候是通过操作数栈来进行的，又或者在调用其他方法的时候是通过操作数栈来进行参数的传递


###### 注意

在概念模型中，两个栈帧作为虚拟机栈的元素，是完全独立的。但是在大多数虚拟机实现中都会做一些优化，让下面栈帧的部分操作数栈与上面的栈帧的局部变量表重叠，这样在进行方法调用时就可以共用一部分数据，无需进行额外的参数传递

### 动态连接

* 动态连接(Dynamic Linking)，指的是在运行期间动态地连接需要调用的方法。每个栈帧都包含一个指向运行时常量池中该栈帧的所属方法的引用。
* Class 文件的常量池中存在大量的符号引用，字节码的方法调用指令就是以常量池中指向方法的符号引用作为参数，而符号引用在使用时需要转换为直接引用，转化的方式有：
  * **静态解析**：这一部分的符号引用在类加载阶段或者是第一次使用的时候转化为直接引用
  * **动态连接**：这一部分符号引用在运行期间的每一次使用是都要转化为直接引用





### 方法返回地址

* 方法的返回地址用于在方法退出之后，返回到方法被调用的位置

* 当一个方法开始执行后，只有两种方式可以退出这个方法：

  * **正常完成出口(Normal Method Invocation Completion)**：执行引擎遇到任意一个方法返回的字节码指令后发生退出。这个时候是否有返回值和返回值的类型根据遇到的何种方法返回指令来决定
  * **异常完成出口(Abrupt Method Invocation Completion)**：在方法执行过程中遇到异常，并且这个异常没有在方法体内得到处理，导致方法的退出。一个方法以异常完成出口方式退出，不会给它的上层调用者返回任何值

  无论是何种方法退出方式，在方法退出后，都需要返回到方法被调用的位置，程序才能够继续执行。方法退出的过程实际上等同于将当前栈帧出栈，一次退出时可能执行的操作有：恢复上层方法的ubuntu变量表和操作数栈，把返回值（如果有的话）压入调用者栈帧的操作数帧中，调整 PC 计数器的值来指向方法执行指令后面的一条指令



### 附加信息

* 虚拟机规范允许具体的虚拟机实现中增加一些规范中没有描述的信息到栈帧中，这部分信息完全取决于具体的虚拟机实现。
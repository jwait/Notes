###1.运行时数据区域
Java 虚拟机在执行 Java 程序的过程中会把它所管理的内存区域划分为若干个不同的数据区域。这些区域都有各自的用途，以及创建和销毁的时间。
Java 虚拟机管理的内存将会包括以下几个运行时数据区域：

![](http://www.regenthypo.com/images/jrd_1.jpg)

####程序计数器（Program Counter Register）
* 程序计数器是一块较小的内存空间，它可以看作是当前线程所执行字节码的行号指示器，字节码解析器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，例如：分支、循环、跳转、异常处理、线程恢复等基础功能
* 程序计数器是线程私有的。由于 Java 虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，因此为了线程切换后能恢复到正确的执行位置，每一条线程都需要一个独立的程序计数器，各条线程之间计算器互不影响，独立存储。
* 如果线程正在执行的是一个 Java 方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是 Native 方法，这个计数器为空
* 程序计数器内存区域是唯一一个没有规定任何 `OutOfMemoryError` 情况的区域

####Java 虚拟机栈(Java Virtual Machine Stack)
* 虚拟机栈描述的是 Java 方法执行的内存模型：每一方法执行的同时都会创建一个栈帧(Stack Frame)用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，都对应着一个栈帧在虚拟机栈中入栈和出栈的过程
* 局部变量表存放了编译器可知的各种基本数据模型、对象引用和 returnAddress 类型，而这个局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多少的局部变量空间是完全确定的，在方法运行期间不会改变
* 与程序计数器一样，Java 虚拟机栈也是线程私有的，其生命周期与线程相同
* 该内存区域规定了两种异常情况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出 `StackOverflowError` 异常；如果虚拟机栈可以动态扩展，但扩展是无法申请到足够的内存，就会抛出`OutOfMemoryError` 异常

####本地方法栈(Native Method Stack)
* 本地方法栈与虚拟机栈所发挥的作用是类似的：虚拟机栈是为虚拟机执行 Java 方法服务，而本地方法栈是为虚拟机使用到的 Native 方法服务
* 与虚拟机栈一样，本地方法栈区域会抛出 `StackOverflowError` 异常和 `OutOfMemoryError` 异常
* 虚拟机规范并未对本地方法栈进行强制规定，虚拟机可以自由地实现，甚至有的虚拟机直接就把本地方法栈与虚拟机栈合并

####Java 堆(Java Heap)
* Java 堆是 Java 虚拟机所管理的内存区域中最大的一块。Java 堆是被所有线程共享的一块内存区域，在虚拟机启动是创建。此内存区域的唯一目的是存放对象实例，几乎所有的对象实例都在这里分配内存
* Java 堆是垃圾收集器管理的主要区域。从内存回收的角度来看，由于收集器基本采用分代收集算法，故Java 堆还可以细分为：新生代和老年代，再细致一点的有 Eden 空间、From Survivor 空间、To Survivor 空间等；从内存分配的角度来看，可能划分出多个线程私有的分配缓存区域
* Java 堆可以处于物理上不连续的内存区域中，只要逻辑上是连续即可
* Java 堆一般都是可以扩展的，如果在堆中没有内存完成实例分配，并且堆也无法在扩展时，将会抛出 `OutOfMemoryError` 异常

####方法区(Method Area、Non-Heap)
* 方法区与 Java 堆一样，是各个线程共享的内存区域
* 方法区用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器后的代码等数据
* 方法区和 Java 堆一样不需要连续的内存和可以选择固定大小或者可扩展外。
* 方法区可能发生垃圾回收行为，这区域内存回收的主要目标是针对常量池的回收和类型的卸载，但一般来所，这个区域的回收“成绩”比较难以令人满意
* 当方法区无法满足内存分配需求是，将抛出 `OutOfMemoryError` 异常

####运行时常量池(Runtime Constant Pool)
* 运行时常量池是方法区的一部分。用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放
* 由于运行时常量池是方法区的一部分，受到方法区的内存限制，当常量池无法再申请到内存是会抛出 `OutOfMemoryError` 异常

###2.对象的创建
####创建过程
1. 虚拟机遇到一条 new 指令时，进行类加载检查，如果需要将执行相应的类加载过程
2. 虚拟机为新生对象分配内存
3. 虚拟机将分配到的内存空间都初始化为零值（不包括对象头），这一过程也可以提前到 TLAB 分配是进行
4. 虚拟机对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等，这些信息都存放再对象的对象头中
5. 从虚拟机的视角来看，一个对象已经产生，但从 Java 程序员的视角来看，此时对象还需要执行`<init>` 方法

####涉及的相关问题：
#####类加载检查
检查 new 指令的参数是否能在常量池中定位到一个类的引用，并且检查这个符号引用代表的类是否已被加载、解析、和初始化过。如果没有则必须执行相应的类加载过程

#####内存分配问题
对象所需的内存的大小在类加载完成后便可以完全确定，为对象分配空间的任务等同于把一块大小确定的内存从 Java 堆中划分出来

根据Java 堆内存是否规整，有以下的分配方式
* **指针碰撞(Bump the pointer)** ：Java 堆中的内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配的内存就仅仅是把那个指针向空闲的空间挪动一段距离
* **空闲列表(Free List)**：Java 堆中的内存并不是规整的，已使用的内存与空闲的内存相互交错，那就没有办法简单地进行指针碰撞，虚拟机必须维护一个列表，记录上哪些内存块是可用的，在分配的时候就从列表中找出一块足够大的空间划分给对象实例，并更新列表上的记录

选择哪一种分配方式由 Java 堆是否规整决定的，而 Java 堆是否规整又由所采用的垃圾收集器是否带由压缩整理功能决定的，因此在使用 Serial，ParNew 等带 Compact 过程的垃圾收集器时，系统采用的分配方式时指针碰撞，而使用 CMS 这种基于 Mark-Sweep 算法得收集器时，通常采用空闲列表

#####对象创建过程中得线程安全问题
由于对象创建在 Java 虚拟机中是非常频繁得行为，即使是仅仅修改一个指针所指得位置，在并发情况下也并不是线程安全得，可能出现正在给 A 对象分配内存，指针还没来得及修改，对象 B 又同时使用了原来得指针来分配内存得情况
解决这一问题有两种方案：
* **方案一**:对分配内存空间得动作进行同步处理——实际上虚拟机采用 CAS 配上失败重试得方式保证操作得原子性
* **方案二**:把内存分配的动作按照线程划分在不同的空间中进行，即每个线程在 Java 堆中预先分配一小块的内存，称为本地线程分配缓冲(Thread Local Allocation Buffer，TLAB)。哪个线程需要分配内存，就在哪个线程上的 TLAB 分配，只有 TLAB 用完并分配新的 TLAB 时，在需要同步锁定

#####内存空间初始化的原因
这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能够访问到这些字段的数据类型所对应的零值

###3）对象的内存布局
在HotSpot 虚拟机中，对象在内存中的存储布局可以分为3块区域：对象头(Header)、实例数据(Instance Data)和对齐填充(Padding)
* **对象头(Header)**：HotSpot 虚拟机的对象头包括两部分的信息，第一部分是存储对象自身的数据，第二部分是类型指针。
	* 第一部分时存储对象自身的运行时数据，如哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，这部分数据的长度在32位到64位的虚拟机中分别为32bit和64bit，称为“Mark Word”。但是由于对象头信息与对象自身定义的数据无关的额外存储成本。考虑到虚拟机的空间效率，Mark Word 被设计成一个非固定的数据结构以便在极小的空间内存储尽量多的信息
	* 第二部分时类型指针，类型指针即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。并不是所有的虚拟机实现都必须在对象数据上保留类型指针，换句话所，查找对象的元数据信息并不是要经过对象本身
* **实例数据(Instance Data)**：实例数据部分存储的是对象真正的有效信息，也是程序代码中所定义的的各种类型的字段内容。无论是从父类继承下来的，还是在子类中定义的，都需要记录起来，这部分的存储顺序回受到虚拟机分配策略参数和字段在 Java 源码中定义顺序的影响
* **对齐填充(Padding)**：由于 HotSpot VM 的自动内存管理系统要求对象的起始地址必须是8字节的整数倍，而对象头的部分正好是8字节的倍数，因此但对象实例数据部分没有对齐时，就需要通过对齐填充来补全

###4）对象的访问定位
为了使用对象，我们的 Java 程序程序需要通过栈上的 reference 数据来操作堆上的具体对象。目前主流的访问方式有**使用句柄**和**直接指针**两种

* **使用句柄**：如果使用句柄，Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息
![](http://img.my.csdn.net/uploads/201209/26/1348659242_7055.jpg)

* **直接指针**：如果使用直接指针访问，那么 reference 中存储的直接就是对象地址，而需要在 Java 堆对象的布局中放置访问类型数据的相关信息的方式
![](http://img.my.csdn.net/uploads/201209/26/1348658605_5211.jpg)

######优缺点：
* 使用句柄最大的好处就是 reference 中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象时非常普遍的现象）时只会改变句柄中的实例数据指针，而 reference 本身不需要修改
* 使用直接指针的方式的最大好处就是速度快，它节省了一次指针定位的时间开销，由于对象的访问在 Java 中非常的频繁，因此此类访问方式效率较高

Sun HotSpot 使用第二中方式进行对象访问

